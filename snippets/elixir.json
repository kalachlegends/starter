{"for":{"prefix":"for","description":"for","scope":"source.elixir","body":"for ${1:item} <- ${2:items} do\n  $0\nend"},"debug time":{"prefix":"debug time","body":["{time, result} = :timer.tc(fn ->","  ${1:}","end)","{time / 1_000, time / 1_000_000, result}"]},"if":{"prefix":"if","description":"if","scope":"source.elixir","body":"if $1 do\n  $0\nend"},"describe":{"prefix":"describe","description":"describe","scope":"source.elixir","body":"describe \"$1\" do\n\t$0\nend"},"df":{"prefix":"df","description":"def (one line)","scope":"source.elixir","body":"def $1, do: $0"},"defpro":{"prefix":"defpro","description":"defprotocol","scope":"source.elixir","body":"defprotocol $1 do\n  $0\nend"},"trc":{"prefix":"trc","description":"try catch","scope":"source.elixir","body":"try do\n  $0\ncatch\n $1 -> $2\nend"},"mfs":{"prefix":"mfs","description":"Map from Struct","scope":"source.elixir","body":"Map.from_struct($0)"},"Supervisor":{"prefix":"supervisor","description":"Insert code for an OTP Supervisor","scope":"source.elixir","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse Supervisor","","\tdef start_link(${args}) do","\t\tSupervisor.start_link(__MODULE__, [${args}], name: __MODULE__)","\tend","","\tdef init([${args}]) do","\t\tchildren = []","","\t\tSupervisor.init(children, strategy: :one_for_one)","\tend","end"]},"ExUnit":{"prefix":["ex_unit","exu"],"description":"Insert code for a ExUnit","scope":"source.elixir","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse ExUnit.Case","\tdoctest$1","","\tdescribe \"${2:description_of_tests}\" do","\t\ttest \"${3:definition_of_this_test}\" do","\t\tend","\tend","end"]},"if:":{"prefix":"if:","description":"if (one line)","scope":"source.elixir","body":"if $1, do: $0"},"wt":{"prefix":"wt","description":"with","scope":"source.elixir","body":["with $1 do","\t$0","end"]},"ok":{"prefix":"ok","description":"{:ok, ... } ...","scope":"source.elixir","body":"{:ok, $1} $0"},"defmc":{"prefix":"defmc","description":"defmacrocallback","scope":"source.elixir","body":"defmacrocallback $1 :: $0"},"iill":{"prefix":"iill","description":"IO.inspect(label: \"<optional message>; Module:line_nr\")","scope":"source.elixir","body":"IO.inspect(label: \"${0:message; }#{String.replace_leading(\"#{__ENV__.file}\", \"#{File.cwd!()}\",\"\")|> Path.relative()}:#{__ENV__.line()}\")"},"ife:":{"prefix":"ife:","description":"if else (one line)","scope":"source.elixir","body":"if $1, do: $2, else: $0"},"pe":{"prefix":"pe","description":"print_eex","scope":"text.elixir,text.html.elixir","body":"<%= $0 %>"},"iip":{"prefix":"iip","description":"IO.inspect() piped value with module name & line number","scope":"source.elixir","body":"|> IO.inspect(label: \"#{__MODULE__}:#{__ENV__.line} #{DateTime.utc_now}\", limit: :infinity)"},"testc":{"prefix":"testc","description":"test with context","scope":"source.elixir","body":"test \"$1\", %{$2} do\n\t$0\nend"},"i":{"prefix":"i","description":"inspect","scope":"source.elixir","body":"inspect($0)"},"err":{"prefix":"error","description":"{:error, ... } ...","scope":"source.elixir","body":"{:error, $1} $0"},"oke":{"prefix":"ok","description":"{:ok, ... } = ...","scope":"source.elixir","body":"{:ok, $1} = $0"},"defd":{"prefix":"defd","description":"defdelegate","scope":"source.elixir","body":"defdelegate $1 to: $0"},"unless:":{"prefix":"unless:","description":"unless (one line)","scope":"source.elixir","body":"unless $1, do: $0"},"erre":{"prefix":"error","description":"{:error, ... } = ...","scope":"source.elixir","body":"{:error, $1} = $0"},"unlesse":{"prefix":"unlesse","description":"unless else","scope":"source.elixir","body":"unless $1 do\n  $2\nelse\n  $0\nend"},"defp":{"prefix":"defp","description":"defp","scope":"source.elixir","body":"defp $1 do\n\t$0\nend"},"defe":{"prefix":"defe","description":"defexception","scope":"source.elixir","body":"defexception [${1::message}]"},"ist":{"prefix":"ist","description":"`IO.inspect` the current stacktrace","scope":"source.elixir","body":"IO.inspect(Process.info(self(), :current_stacktrace), label: \"STACKTRACE\", limit: :infinity)"},"is_b":{"prefix":"is_b","body":"is_boolean(${1:})"},"ii":{"prefix":"ii","description":"IO.inspect","scope":"source.elixir","body":"IO.inspect($0)"},"unless":{"prefix":"unless","description":"unless","scope":"source.elixir","body":"unless $1 do\n  $0\nend"},"schma":{"prefix":"schma","body":["{","      \"shipping_date\" => %{","        __vali__: &(MsPP.Engines.CargoProcedure.FieldValueLogic.validate_shipping_date/2)","      },","      \"cargo_type_of_transport\" => %{","        __vali__: MsPP.Utils.CustomValidators.validate_length_list_by_op(:>, 0)","      },","      \"sum_of_positions_exchanges\" => %{","        __vali__: Vali.Validators.gt(0),","      },","      \"period_of_trading\" => %{","        __vali__: [Vali.Validators.gt(0), Vali.Validators.lt(91)],","      },","      \"cargo_weight_brutto_tons\" => %{","        error_label: gettext(\"Вес груза брутто\"),","        __vali__: fn value, state ->","          cond do","            is_nil(FA.value(state, \"cargo_weight_netto_tons\")) -> :valid","            value < FA.value(state, \"cargo_weight_netto_tons\") -> {:invalid, gettext(\"Брутто не может быть меньше чем нетто\")}","            true -> :valid","          end","        end,","      },","      \"cargo_weight_netto_tons\" => %{","        error_label: gettext(\"Вес груза нетто\"),","        __vali__: fn value, state ->","          cond do","            value > FA.value(state, \"cargo_weight_brutto_tons\") -> {:invalid, gettext(\"Нетто не может быть больше чем брутто\")}","            true -> :valid","          end","        end,","      }","    }"]},"defs":{"prefix":"defs","description":"defstruct","scope":"source.elixir","body":"defstruct $1: $2"},"mdoc":{"prefix":"mdoc","description":"moduledoc","scope":"source.elixir","body":"@moduledoc \"\"\"\n$0\n\"\"\""},"iib":{"prefix":"iib","description":"IO.inspect() binding() with module name & line number","scope":"source.elixir","body":"IO.inspect(binding(), label: \"binding() #{__MODULE__}:#{__ENV__.line} #{DateTime.utc_now}\", limit: :infinity)"},"defmp":{"prefix":"defmp","description":"defmacrop","scope":"source.elixir","body":"defmacrop $1 do\n\t$0\nend"},"mpn":{"prefix":"mpn","description":"Puts the given value under key unless the entry key already exists in map","scope":"source.elixir","body":"Map.put_new(${1:map}, ${2:key}, ${3:value})"},"req":{"prefix":"req","description":"require","scope":"source.elixir","body":"require $0"},"Inspect with relative path and line nr":{"prefix":"iins","description":"`IO.inspect` with a label containing relative path and line number. Label string can easily be discarded","scope":"source.elixir","body":"|> IO.inspect(label: \"${0:${RELATIVE_FILEPATH}:${TM_LINE_NUMBER}}\")"},"cond":{"prefix":"cond","description":"cond","scope":"source.elixir","body":"cond do\n  $1 ->\n    $0\nend"},"ip":{"prefix":"iip","description":"IO.puts(..)","scope":"source.elixir","body":"IO.puts(\"$0\")"},"dataSource":{"prefix":"dataSource","body":"dataSource: %{store: %{ref: \"${1:}\"}},"},"DynamicSupervisor":{"prefix":"dynamic_supervisor","description":"Insert code for a DynamicSupervisor","scope":"source.elixir","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse DynamicSupervisor","","\tdef start_link(${init_args}) do","\t\tDynamicSupervisor.start_link(__MODULE__, [${init_args}], name: __MODULE__)","\tend","","\tdef start_child(${child_args}) do","\t\tchild_spec = %{","\t\t\tid: ${ChildModule},","\t\t\tstart: {${ChildModule}, :start_link, [${child_args}]},","\t\t\trestart: :transient,","\t\t\tshutdown: :brutal_kill,","\t\t\ttype: :worker,","\t\t\tmodules: [${ChildModule}],","\t\t}","","\t\tDynamicSupervisor.start_child(__MODULE__, child_spec)","\tend","","\tdef init([${init_args}]) do","\t\tDynamicSupervisor.init(strategy: :one_for_one)","\tend","end"]},"mp":{"prefix":"mp","description":"Puts the given value under key in map","scope":"source.elixir","body":"Map.put(${1:map}, ${2:key}, ${3:value})"},"defc":{"prefix":"defc","description":"defcallback","scope":"source.elixir","body":"defcallback $1 :: $0"},"case":{"prefix":"case","description":"case","scope":"source.elixir","body":"case $1 do\n  $2 ->\n    $0\nend"},"%":{"prefix":"%","description":"map/struct","scope":"source.elixir","body":"%${1:Struct}{$2}$0"},":":{"prefix":":","description":"value: value","scope":"source.elixir","body":"${1:value}: ${1:value}$0"},"extract_locale":{"prefix":"extract_locale","body":["def extract_locale(params) do","    case params[:lang] do","      \"ru\" -> \"ru_RU\"","      \"ru_kg\" -> \"ru_RU@kg\"","      \"uz\" -> \"uz_UZ@cyrillic\"","      \"kg\" -> \"ky_KG\"","      \"en\" -> \"en_US\"","      \"en_kg\" -> \"en_US@kg\"","      o -> o","    end","  end"]},"imp":{"prefix":"imp","description":"import","scope":"source.elixir","body":"import $0"},"::":{"prefix":"::","description":"key => value","scope":"source.elixir","body":"${1:key} => ${2:value}$0"},"defi":{"prefix":"defi","description":"defimpl","scope":"source.elixir","body":"defimpl $1, for: $2 do\n  $0\nend"},"dmac":{"prefix":["dmac","defmac"],"description":"defmacro","scope":"source.elixir","body":"defmacro $1 do\n\t$0\nend"},"wte":{"prefix":"wte","description":"with/else","scope":"source.elixir","body":["with $1 do","\t$0","else","\t$2 -> $3","end"]},"fori":{"prefix":"fori","description":"for into","scope":"source.elixir","body":"for ${1:item} <- ${2:items}, into: ${3:[]} do;\n  $0\nend"},"p":{"prefix":"p","description":"your favorite pipeline (|>)","scope":"text.elixir","body":"|> $0"},"doc":{"prefix":"doc","description":"doc","scope":"source.elixir","body":"@doc \"\"\"\n$0\n\"\"\""},"trr":{"prefix":"trr","description":"try rescue (everything!)","scope":"source.elixir","body":"try do\n  $0\nrescue\n  _ -> :rescued\nend"},"fn":{"prefix":"fn","description":"fn","scope":"source.elixir","body":"fn ${1:args} -> $2 end$0"},"do":{"prefix":"do","description":"do","scope":"source.elixir","body":"do\n\t$0\nend"},"GenServer":{"prefix":"gen_server","description":"Insert code for a OTP GenServer","scope":"source.elixir","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse GenServer","","\tdef start_link(${init_args}) do","\t\t# you may want to register your server with `name: __MODULE__`","\t\t# as a third argument to `start_link`","\t\tGenServer.start_link(__MODULE__, [${init_args}])","\tend","","\tdef init(_args) do","\t\t{:ok, :initial_state}","\tend","end"]},"msan":{"prefix":"msan","description":"sanitize a map by dropping some keys","scope":"source.elixir","body":"Map.drop(${1:map, }[${2:keys}])"},"ee":{"prefix":"ee","description":"embed_eex","scope":"text.elixir,text.html.elixir","body":"<% $0 %>"},"unlesse:":{"prefix":"unlesse:","description":"unless else (one line)","scope":"source.elixir","body":"unless $1, do: $2, else: $0"},"ife":{"prefix":"ife","description":"if else","scope":"source.elixir","body":"if $1 do\n  $2\nelse\n  $0\nend"},"pry":{"prefix":"pry","description":"Debug with IEx.pry","scope":"source.elixir","body":"require IEx; IEx.pry"},"rec":{"prefix":"rec","description":"receive","scope":"source.elixir","body":"receive do\n\t${1:{${2::${3:message_type}}, ${4:value}\\}} ->\n    ${0:# code}\nend\n"},"iil":{"prefix":"iil","description":"IO.inspect(label: ...)","scope":"source.elixir","body":"IO.inspect(label: \"$0\")"},"dmod":{"description":"def module","scope":"source.elixir","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\t$0","end"],"comments":["Generates the namespace for a file.","e.g. A file with the path `lib/foo/bar/baz/boing.ex` would resolve to Foo.Bar.Baz.Boing."],"prefix":["dmod","defmod"]},"test":{"prefix":"test","description":"test","scope":"source.elixir","body":"test \"$1\" do\n\t$0\nend"},"map_join_sql_in":{"prefix":"map_join_sql_in","body":"|> Enum.map_join(\"${1:,}\", &(\"'#{&1[${2:proc_id}]}'\"))"},"def":{"prefix":"def","description":"def","scope":"source.elixir","body":"def $1 do\n\t$0\nend"}}