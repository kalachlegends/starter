{"ist":{"description":"`IO.inspect` the current stacktrace","prefix":"ist","body":"IO.inspect(Process.info(self(), :current_stacktrace), label: \"STACKTRACE\", limit: :infinity)","scope":"source.elixir"},"ii":{"description":"IO.inspect","prefix":"ii","body":"IO.inspect($0)","scope":"source.elixir"},"unless":{"description":"unless","prefix":"unless","body":"unless $1 do\n  $0\nend","scope":"source.elixir"},"fn":{"description":"fn","prefix":"fn","body":"fn ${1:args} -> $2 end$0","scope":"source.elixir"},"mfs":{"description":"Map from Struct","prefix":"mfs","body":"Map.from_struct($0)","scope":"source.elixir"},"iil":{"description":"IO.inspect(label: ...)","prefix":"iil","body":"IO.inspect(label: \"$0\")","scope":"source.elixir"},"%":{"description":"map/struct","prefix":"%","body":"%${1:Struct}{$2}$0","scope":"source.elixir"},"unlesse":{"description":"unless else","prefix":"unlesse","body":"unless $1 do\n  $2\nelse\n  $0\nend","scope":"source.elixir"},"iib":{"description":"IO.inspect() binding() with module name & line number","prefix":"iib","body":"IO.inspect(binding(), label: \"binding() #{__MODULE__}:#{__ENV__.line} #{DateTime.utc_now}\", limit: :infinity)","scope":"source.elixir"},"wt":{"description":"with","prefix":"wt","body":["with $1 do","\t$0","end"],"scope":"source.elixir"},"ExUnit":{"description":"Insert code for a ExUnit","prefix":["ex_unit","exu"],"body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse ExUnit.Case","\tdoctest$1","","\tdescribe \"${2:description_of_tests}\" do","\t\ttest \"${3:definition_of_this_test}\" do","\t\tend","\tend","end"],"scope":"source.elixir"},"iip":{"description":"IO.inspect() piped value with module name & line number","prefix":"iip","body":"|> IO.inspect(label: \"#{__MODULE__}:#{__ENV__.line} #{DateTime.utc_now}\", limit: :infinity)","scope":"source.elixir"},"dataSource":{"body":"dataSource: %{store: %{ref: \"${1:}\"}},","prefix":"dataSource"},"i":{"description":"inspect","prefix":"i","body":"inspect($0)","scope":"source.elixir"},"cond":{"description":"cond","prefix":"cond","body":"cond do\n  $1 ->\n    $0\nend","scope":"source.elixir"},"p":{"description":"your favorite pipeline (|>)","prefix":"p","body":"|> $0","scope":"text.elixir"},"oke":{"description":"{:ok, ... } = ...","prefix":"ok","body":"{:ok, $1} = $0","scope":"source.elixir"},"err":{"description":"{:error, ... } ...","prefix":"error","body":"{:error, $1} $0","scope":"source.elixir"},"wte":{"description":"with/else","prefix":"wte","body":["with $1 do","\t$0","else","\t$2 -> $3","end"],"scope":"source.elixir"},"mp":{"description":"Puts the given value under key in map","prefix":"mp","body":"Map.put(${1:map}, ${2:key}, ${3:value})","scope":"source.elixir"},"defc":{"description":"defcallback","prefix":"defc","body":"defcallback $1 :: $0","scope":"source.elixir"},"defi":{"description":"defimpl","prefix":"defi","body":"defimpl $1, for: $2 do\n  $0\nend","scope":"source.elixir"},"GenServer":{"description":"Insert code for a OTP GenServer","prefix":"gen_server","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse GenServer","","\tdef start_link(${init_args}) do","\t\t# you may want to register your server with `name: __MODULE__`","\t\t# as a third argument to `start_link`","\t\tGenServer.start_link(__MODULE__, [${init_args}])","\tend","","\tdef init(_args) do","\t\t{:ok, :initial_state}","\tend","end"],"scope":"source.elixir"},":":{"description":"value: value","prefix":":","body":"${1:value}: ${1:value}$0","scope":"source.elixir"},"defp":{"description":"defp","prefix":"defp","body":"defp $1 do\n\t$0\nend","scope":"source.elixir"},"dmac":{"description":"defmacro","prefix":["dmac","defmac"],"body":"defmacro $1 do\n\t$0\nend","scope":"source.elixir"},"doc":{"description":"doc","prefix":"doc","body":"@doc \"\"\"\n$0\n\"\"\"","scope":"source.elixir"},"mpn":{"description":"Puts the given value under key unless the entry key already exists in map","prefix":"mpn","body":"Map.put_new(${1:map}, ${2:key}, ${3:value})","scope":"source.elixir"},"df":{"description":"def (one line)","prefix":"df","body":"def $1, do: $0","scope":"source.elixir"},"def":{"description":"def","prefix":"def","body":"def $1 do\n\t$0\nend","scope":"source.elixir"},"do":{"description":"do","prefix":"do","body":"do\n\t$0\nend","scope":"source.elixir"},"defd":{"description":"defdelegate","prefix":"defd","body":"defdelegate $1 to: $0","scope":"source.elixir"},"rec":{"description":"receive","prefix":"rec","body":"receive do\n\t${1:{${2::${3:message_type}}, ${4:value}\\}} ->\n    ${0:# code}\nend\n","scope":"source.elixir"},"testc":{"description":"test with context","prefix":"testc","body":"test \"$1\", %{$2} do\n\t$0\nend","scope":"source.elixir"},"ok":{"description":"{:ok, ... } ...","prefix":"ok","body":"{:ok, $1} $0","scope":"source.elixir"},"for":{"description":"for","prefix":"for","body":"for ${1:item} <- ${2:items} do\n  $0\nend","scope":"source.elixir"},"trc":{"description":"try catch","prefix":"trc","body":"try do\n  $0\ncatch\n $1 -> $2\nend","scope":"source.elixir"},"defs":{"description":"defstruct","prefix":"defs","body":"defstruct $1: $2","scope":"source.elixir"},"if":{"description":"if","prefix":"if","body":"if $1 do\n  $0\nend","scope":"source.elixir"},"DynamicSupervisor":{"description":"Insert code for a DynamicSupervisor","prefix":"dynamic_supervisor","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse DynamicSupervisor","","\tdef start_link(${init_args}) do","\t\tDynamicSupervisor.start_link(__MODULE__, [${init_args}], name: __MODULE__)","\tend","","\tdef start_child(${child_args}) do","\t\tchild_spec = %{","\t\t\tid: ${ChildModule},","\t\t\tstart: {${ChildModule}, :start_link, [${child_args}]},","\t\t\trestart: :transient,","\t\t\tshutdown: :brutal_kill,","\t\t\ttype: :worker,","\t\t\tmodules: [${ChildModule}],","\t\t}","","\t\tDynamicSupervisor.start_child(__MODULE__, child_spec)","\tend","","\tdef init([${init_args}]) do","\t\tDynamicSupervisor.init(strategy: :one_for_one)","\tend","end"],"scope":"source.elixir"},"trr":{"description":"try rescue (everything!)","prefix":"trr","body":"try do\n  $0\nrescue\n  _ -> :rescued\nend","scope":"source.elixir"},"describe":{"description":"describe","prefix":"describe","body":"describe \"$1\" do\n\t$0\nend","scope":"source.elixir"},"msan":{"description":"sanitize a map by dropping some keys","prefix":"msan","body":"Map.drop(${1:map, }[${2:keys}])","scope":"source.elixir"},"dmod":{"scope":"source.elixir","comments":["Generates the namespace for a file.","e.g. A file with the path `lib/foo/bar/baz/boing.ex` would resolve to Foo.Bar.Baz.Boing."],"description":"def module","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\t$0","end"],"prefix":["dmod","defmod"]},"if:":{"description":"if (one line)","prefix":"if:","body":"if $1, do: $0","scope":"source.elixir"},"defmc":{"description":"defmacrocallback","prefix":"defmc","body":"defmacrocallback $1 :: $0","scope":"source.elixir"},"schma":{"body":["{","      \"shipping_date\" => %{","        __vali__: &(MsPP.Engines.CargoProcedure.FieldValueLogic.validate_shipping_date/2)","      },","      \"cargo_type_of_transport\" => %{","        __vali__: MsPP.Utils.CustomValidators.validate_length_list_by_op(:>, 0)","      },","      \"sum_of_positions_exchanges\" => %{","        __vali__: Vali.Validators.gt(0),","      },","      \"period_of_trading\" => %{","        __vali__: [Vali.Validators.gt(0), Vali.Validators.lt(91)],","      },","      \"cargo_weight_brutto_tons\" => %{","        error_label: gettext(\"Вес груза брутто\"),","        __vali__: fn value, state ->","          cond do","            is_nil(FA.value(state, \"cargo_weight_netto_tons\")) -> :valid","            value < FA.value(state, \"cargo_weight_netto_tons\") -> {:invalid, gettext(\"Брутто не может быть меньше чем нетто\")}","            true -> :valid","          end","        end,","      },","      \"cargo_weight_netto_tons\" => %{","        error_label: gettext(\"Вес груза нетто\"),","        __vali__: fn value, state ->","          cond do","            value > FA.value(state, \"cargo_weight_brutto_tons\") -> {:invalid, gettext(\"Нетто не может быть больше чем брутто\")}","            true -> :valid","          end","        end,","      }","    }"],"prefix":"schma"},"ife":{"description":"if else","prefix":"ife","body":"if $1 do\n  $2\nelse\n  $0\nend","scope":"source.elixir"},"is_b":{"body":"is_boolean(${1:})","prefix":"is_b"},"unlesse:":{"description":"unless else (one line)","prefix":"unlesse:","body":"unless $1, do: $2, else: $0","scope":"source.elixir"},"ife:":{"description":"if else (one line)","prefix":"ife:","body":"if $1, do: $2, else: $0","scope":"source.elixir"},"defmp":{"description":"defmacrop","prefix":"defmp","body":"defmacrop $1 do\n\t$0\nend","scope":"source.elixir"},"test":{"description":"test","prefix":"test","body":"test \"$1\" do\n\t$0\nend","scope":"source.elixir"},"Inspect with relative path and line nr":{"description":"`IO.inspect` with a label containing relative path and line number. Label string can easily be discarded","prefix":"iins","body":"|> IO.inspect(label: \"${0:${RELATIVE_FILEPATH}:${TM_LINE_NUMBER}}\")","scope":"source.elixir"},"fori":{"description":"for into","prefix":"fori","body":"for ${1:item} <- ${2:items}, into: ${3:[]} do;\n  $0\nend","scope":"source.elixir"},"mdoc":{"description":"moduledoc","prefix":"mdoc","body":"@moduledoc \"\"\"\n$0\n\"\"\"","scope":"source.elixir"},"case":{"description":"case","prefix":"case","body":"case $1 do\n  $2 ->\n    $0\nend","scope":"source.elixir"},"defe":{"description":"defexception","prefix":"defe","body":"defexception [${1::message}]","scope":"source.elixir"},"ip":{"description":"IO.puts(..)","prefix":"iip","body":"IO.puts(\"$0\")","scope":"source.elixir"},"defpro":{"description":"defprotocol","prefix":"defpro","body":"defprotocol $1 do\n  $0\nend","scope":"source.elixir"},"::":{"description":"key => value","prefix":"::","body":"${1:key} => ${2:value}$0","scope":"source.elixir"},"req":{"description":"require","prefix":"req","body":"require $0","scope":"source.elixir"},"pry":{"description":"Debug with IEx.pry","prefix":"pry","body":"require IEx; IEx.pry","scope":"source.elixir"},"erre":{"description":"{:error, ... } = ...","prefix":"error","body":"{:error, $1} = $0","scope":"source.elixir"},"imp":{"description":"import","prefix":"imp","body":"import $0","scope":"source.elixir"},"ee":{"description":"embed_eex","prefix":"ee","body":"<% $0 %>","scope":"text.elixir,text.html.elixir"},"unless:":{"description":"unless (one line)","prefix":"unless:","body":"unless $1, do: $0","scope":"source.elixir"},"iill":{"description":"IO.inspect(label: \"<optional message>; Module:line_nr\")","prefix":"iill","body":"IO.inspect(label: \"${0:message; }#{String.replace_leading(\"#{__ENV__.file}\", \"#{File.cwd!()}\",\"\")|> Path.relative()}:#{__ENV__.line()}\")","scope":"source.elixir"},"Supervisor":{"description":"Insert code for an OTP Supervisor","prefix":"supervisor","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse Supervisor","","\tdef start_link(${args}) do","\t\tSupervisor.start_link(__MODULE__, [${args}], name: __MODULE__)","\tend","","\tdef init([${args}]) do","\t\tchildren = []","","\t\tSupervisor.init(children, strategy: :one_for_one)","\tend","end"],"scope":"source.elixir"},"pe":{"description":"print_eex","prefix":"pe","body":"<%= $0 %>","scope":"text.elixir,text.html.elixir"}}