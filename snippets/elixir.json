{"df":{"body":"def $1, do: $0","prefix":"df","scope":"source.elixir","description":"def (one line)"},"::":{"body":"${1:key} => ${2:value}$0","prefix":"::","scope":"source.elixir","description":"key => value"},"wt":{"body":["with $1 do","\t$0","end"],"prefix":"wt","scope":"source.elixir","description":"with"},"describe":{"body":"describe \"$1\" do\n\t$0\nend","prefix":"describe","scope":"source.elixir","description":"describe"},"defi":{"body":"defimpl $1, for: $2 do\n  $0\nend","prefix":"defi","scope":"source.elixir","description":"defimpl"},"dmac":{"body":"defmacro $1 do\n\t$0\nend","prefix":["dmac","defmac"],"scope":"source.elixir","description":"defmacro"},"defmc":{"body":"defmacrocallback $1 :: $0","prefix":"defmc","scope":"source.elixir","description":"defmacrocallback"},"i":{"body":"inspect($0)","prefix":"i","scope":"source.elixir","description":"inspect"},"iill":{"body":"IO.inspect(label: \"${0:message; }#{String.replace_leading(\"#{__ENV__.file}\", \"#{File.cwd!()}\",\"\")|> Path.relative()}:#{__ENV__.line()}\")","prefix":"iill","scope":"source.elixir","description":"IO.inspect(label: \"<optional message>; Module:line_nr\")"},"ok":{"body":"{:ok, $1} $0","prefix":"ok","scope":"source.elixir","description":"{:ok, ... } ..."},"defp":{"body":"defp $1 do\n\t$0\nend","prefix":"defp","scope":"source.elixir","description":"defp"},"if:":{"body":"if $1, do: $0","prefix":"if:","scope":"source.elixir","description":"if (one line)"},"iip":{"body":"|> IO.inspect(label: \"#{__MODULE__}:#{__ENV__.line} #{DateTime.utc_now}\", limit: :infinity)","prefix":"iip","scope":"source.elixir","description":"IO.inspect() piped value with module name & line number"},"unless":{"body":"unless $1 do\n  $0\nend","prefix":"unless","scope":"source.elixir","description":"unless"},"testc":{"body":"test \"$1\", %{$2} do\n\t$0\nend","prefix":"testc","scope":"source.elixir","description":"test with context"},":":{"body":"${1:value}: ${1:value}$0","prefix":":","scope":"source.elixir","description":"value: value"},"mdoc":{"body":"@moduledoc \"\"\"\n$0\n\"\"\"","prefix":"mdoc","scope":"source.elixir","description":"moduledoc"},"GenServer":{"body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse GenServer","","\tdef start_link(${init_args}) do","\t\t# you may want to register your server with `name: __MODULE__`","\t\t# as a third argument to `start_link`","\t\tGenServer.start_link(__MODULE__, [${init_args}])","\tend","","\tdef init(_args) do","\t\t{:ok, :initial_state}","\tend","end"],"prefix":"gen_server","scope":"source.elixir","description":"Insert code for a OTP GenServer"},"mp":{"body":"Map.put(${1:map}, ${2:key}, ${3:value})","prefix":"mp","scope":"source.elixir","description":"Puts the given value under key in map"},"defd":{"body":"defdelegate $1 to: $0","prefix":"defd","scope":"source.elixir","description":"defdelegate"},"unless:":{"body":"unless $1, do: $0","prefix":"unless:","scope":"source.elixir","description":"unless (one line)"},"erre":{"body":"{:error, $1} = $0","prefix":"error","scope":"source.elixir","description":"{:error, ... } = ..."},"do":{"body":"do\n\t$0\nend","prefix":"do","scope":"source.elixir","description":"do"},"msan":{"body":"Map.drop(${1:map, }[${2:keys}])","prefix":"msan","scope":"source.elixir","description":"sanitize a map by dropping some keys"},"unlesse":{"body":"unless $1 do\n  $2\nelse\n  $0\nend","prefix":"unlesse","scope":"source.elixir","description":"unless else"},"pry":{"body":"require IEx; IEx.pry","prefix":"pry","scope":"source.elixir","description":"Debug with IEx.pry"},"ee":{"body":"<% $0 %>","prefix":"ee","scope":"text.elixir,text.html.elixir","description":"embed_eex"},"for":{"body":"for ${1:item} <- ${2:items} do\n  $0\nend","prefix":"for","scope":"source.elixir","description":"for"},"defe":{"body":"defexception [${1::message}]","prefix":"defe","scope":"source.elixir","description":"defexception"},"unlesse:":{"body":"unless $1, do: $2, else: $0","prefix":"unlesse:","scope":"source.elixir","description":"unless else (one line)"},"if":{"body":"if $1 do\n  $0\nend","prefix":"if","scope":"source.elixir","description":"if"},"is_b":{"body":"is_boolean(${1:})","prefix":"is_b"},"schma":{"body":["{","      \"shipping_date\" => %{","        __vali__: &(MsPP.Engines.CargoProcedure.FieldValueLogic.validate_shipping_date/2)","      },","      \"cargo_type_of_transport\" => %{","        __vali__: MsPP.Utils.CustomValidators.validate_length_list_by_op(:>, 0)","      },","      \"sum_of_positions_exchanges\" => %{","        __vali__: Vali.Validators.gt(0),","      },","      \"period_of_trading\" => %{","        __vali__: [Vali.Validators.gt(0), Vali.Validators.lt(91)],","      },","      \"cargo_weight_brutto_tons\" => %{","        error_label: gettext(\"Вес груза брутто\"),","        __vali__: fn value, state ->","          cond do","            is_nil(FA.value(state, \"cargo_weight_netto_tons\")) -> :valid","            value < FA.value(state, \"cargo_weight_netto_tons\") -> {:invalid, gettext(\"Брутто не может быть меньше чем нетто\")}","            true -> :valid","          end","        end,","      },","      \"cargo_weight_netto_tons\" => %{","        error_label: gettext(\"Вес груза нетто\"),","        __vali__: fn value, state ->","          cond do","            value > FA.value(state, \"cargo_weight_brutto_tons\") -> {:invalid, gettext(\"Нетто не может быть больше чем брутто\")}","            true -> :valid","          end","        end,","      }","    }"],"prefix":"schma"},"test":{"body":"test \"$1\" do\n\t$0\nend","prefix":"test","scope":"source.elixir","description":"test"},"iil":{"body":"IO.inspect(label: \"$0\")","prefix":"iil","scope":"source.elixir","description":"IO.inspect(label: ...)"},"dmod":{"comments":["Generates the namespace for a file.","e.g. A file with the path `lib/foo/bar/baz/boing.ex` would resolve to Foo.Bar.Baz.Boing."],"description":"def module","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\t$0","end"],"prefix":["dmod","defmod"],"scope":"source.elixir"},"doc":{"body":"@doc \"\"\"\n$0\n\"\"\"","prefix":"doc","scope":"source.elixir","description":"doc"},"imp":{"body":"import $0","prefix":"imp","scope":"source.elixir","description":"import"},"map_join_sql_in":{"body":"|> Enum.map_join(\"${1:,}\", &(\"'#{&1[${2:proc_id}]}'\"))","prefix":"map_join_sql_in"},"wte":{"body":["with $1 do","\t$0","else","\t$2 -> $3","end"],"prefix":"wte","scope":"source.elixir","description":"with/else"},"fori":{"body":"for ${1:item} <- ${2:items}, into: ${3:[]} do;\n  $0\nend","prefix":"fori","scope":"source.elixir","description":"for into"},"fn":{"body":"fn ${1:args} -> $2 end$0","prefix":"fn","scope":"source.elixir","description":"fn"},"ist":{"body":"IO.inspect(Process.info(self(), :current_stacktrace), label: \"STACKTRACE\", limit: :infinity)","prefix":"ist","scope":"source.elixir","description":"`IO.inspect` the current stacktrace"},"trr":{"body":"try do\n  $0\nrescue\n  _ -> :rescued\nend","prefix":"trr","scope":"source.elixir","description":"try rescue (everything!)"},"iib":{"body":"IO.inspect(binding(), label: \"binding() #{__MODULE__}:#{__ENV__.line} #{DateTime.utc_now}\", limit: :infinity)","prefix":"iib","scope":"source.elixir","description":"IO.inspect() binding() with module name & line number"},"ii":{"body":"IO.inspect($0)","prefix":"ii","scope":"source.elixir","description":"IO.inspect"},"defmp":{"body":"defmacrop $1 do\n\t$0\nend","prefix":"defmp","scope":"source.elixir","description":"defmacrop"},"mpn":{"body":"Map.put_new(${1:map}, ${2:key}, ${3:value})","prefix":"mpn","scope":"source.elixir","description":"Puts the given value under key unless the entry key already exists in map"},"Inspect with relative path and line nr":{"body":"|> IO.inspect(label: \"${0:${RELATIVE_FILEPATH}:${TM_LINE_NUMBER}}\")","prefix":"iins","scope":"source.elixir","description":"`IO.inspect` with a label containing relative path and line number. Label string can easily be discarded"},"case":{"body":"case $1 do\n  $2 ->\n    $0\nend","prefix":"case","scope":"source.elixir","description":"case"},"p":{"body":"|> $0","prefix":"p","scope":"text.elixir","description":"your favorite pipeline (|>)"},"dataSource":{"body":"dataSource: %{store: %{ref: \"${1:}\"}},","prefix":"dataSource"},"DynamicSupervisor":{"body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse DynamicSupervisor","","\tdef start_link(${init_args}) do","\t\tDynamicSupervisor.start_link(__MODULE__, [${init_args}], name: __MODULE__)","\tend","","\tdef start_child(${child_args}) do","\t\tchild_spec = %{","\t\t\tid: ${ChildModule},","\t\t\tstart: {${ChildModule}, :start_link, [${child_args}]},","\t\t\trestart: :transient,","\t\t\tshutdown: :brutal_kill,","\t\t\ttype: :worker,","\t\t\tmodules: [${ChildModule}],","\t\t}","","\t\tDynamicSupervisor.start_child(__MODULE__, child_spec)","\tend","","\tdef init([${init_args}]) do","\t\tDynamicSupervisor.init(strategy: :one_for_one)","\tend","end"],"prefix":"dynamic_supervisor","scope":"source.elixir","description":"Insert code for a DynamicSupervisor"},"cond":{"body":"cond do\n  $1 ->\n    $0\nend","prefix":"cond","scope":"source.elixir","description":"cond"},"debug time":{"body":["{time, result} = :timer.tc(fn ->","  ${1:}","end)","{time / 1_000, time / 1_000_000, result}"],"prefix":"debug time"},"req":{"body":"require $0","prefix":"req","scope":"source.elixir","description":"require"},"defpro":{"body":"defprotocol $1 do\n  $0\nend","prefix":"defpro","scope":"source.elixir","description":"defprotocol"},"err":{"body":"{:error, $1} $0","prefix":"error","scope":"source.elixir","description":"{:error, ... } ..."},"def":{"body":"def $1 do\n\t$0\nend","prefix":"def","scope":"source.elixir","description":"def"},"mfs":{"body":"Map.from_struct($0)","prefix":"mfs","scope":"source.elixir","description":"Map from Struct"},"oke":{"body":"{:ok, $1} = $0","prefix":"ok","scope":"source.elixir","description":"{:ok, ... } = ..."},"Supervisor":{"body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse Supervisor","","\tdef start_link(${args}) do","\t\tSupervisor.start_link(__MODULE__, [${args}], name: __MODULE__)","\tend","","\tdef init([${args}]) do","\t\tchildren = []","","\t\tSupervisor.init(children, strategy: :one_for_one)","\tend","end"],"prefix":"supervisor","scope":"source.elixir","description":"Insert code for an OTP Supervisor"},"defc":{"body":"defcallback $1 :: $0","prefix":"defc","scope":"source.elixir","description":"defcallback"},"rec":{"body":"receive do\n\t${1:{${2::${3:message_type}}, ${4:value}\\}} ->\n    ${0:# code}\nend\n","prefix":"rec","scope":"source.elixir","description":"receive"},"ife":{"body":"if $1 do\n  $2\nelse\n  $0\nend","prefix":"ife","scope":"source.elixir","description":"if else"},"alias all":{"prefix":"alias all","body":"alias MsPP.Engines.UZLogic.Utils"},"defs":{"body":"defstruct $1: $2","prefix":"defs","scope":"source.elixir","description":"defstruct"},"pe":{"body":"<%= $0 %>","prefix":"pe","scope":"text.elixir,text.html.elixir","description":"print_eex"},"trc":{"body":"try do\n  $0\ncatch\n $1 -> $2\nend","prefix":"trc","scope":"source.elixir","description":"try catch"},"ife:":{"body":"if $1, do: $2, else: $0","prefix":"ife:","scope":"source.elixir","description":"if else (one line)"},"extract_locale":{"body":["def extract_locale(params) do","    case params[:lang] do","      \"ru\" -> \"ru_RU\"","      \"ru_kg\" -> \"ru_RU@kg\"","      \"uz\" -> \"uz_UZ@cyrillic\"","      \"kg\" -> \"ky_KG\"","      \"en\" -> \"en_US\"","      \"en_kg\" -> \"en_US@kg\"","      o -> o","    end","  end"],"prefix":"extract_locale"},"ip":{"body":"IO.puts(\"$0\")","prefix":"iip","scope":"source.elixir","description":"IO.puts(..)"},"ExUnit":{"body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse ExUnit.Case","\tdoctest$1","","\tdescribe \"${2:description_of_tests}\" do","\t\ttest \"${3:definition_of_this_test}\" do","\t\tend","\tend","end"],"prefix":["ex_unit","exu"],"scope":"source.elixir","description":"Insert code for a ExUnit"},"%":{"body":"%${1:Struct}{$2}$0","prefix":"%","scope":"source.elixir","description":"map/struct"}}