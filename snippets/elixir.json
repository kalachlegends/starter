{"wt":{"scope":"source.elixir","description":"with","prefix":"wt","body":["with $1 do","\t$0","end"]},"err":{"scope":"source.elixir","description":"{:error, ... } ...","prefix":"error","body":"{:error, $1} $0"},"unlesse:":{"scope":"source.elixir","description":"unless else (one line)","prefix":"unlesse:","body":"unless $1, do: $2, else: $0"},"Supervisor":{"scope":"source.elixir","description":"Insert code for an OTP Supervisor","prefix":"supervisor","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse Supervisor","","\tdef start_link(${args}) do","\t\tSupervisor.start_link(__MODULE__, [${args}], name: __MODULE__)","\tend","","\tdef init([${args}]) do","\t\tchildren = []","","\t\tSupervisor.init(children, strategy: :one_for_one)","\tend","end"]},"GenServer":{"scope":"source.elixir","description":"Insert code for a OTP GenServer","prefix":"gen_server","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse GenServer","","\tdef start_link(${init_args}) do","\t\t# you may want to register your server with `name: __MODULE__`","\t\t# as a third argument to `start_link`","\t\tGenServer.start_link(__MODULE__, [${init_args}])","\tend","","\tdef init(_args) do","\t\t{:ok, :initial_state}","\tend","end"]},"msan":{"scope":"source.elixir","description":"sanitize a map by dropping some keys","prefix":"msan","body":"Map.drop(${1:map, }[${2:keys}])"},"%":{"scope":"source.elixir","description":"map/struct","prefix":"%","body":"%${1:Struct}{$2}$0"},"defmc":{"scope":"source.elixir","description":"defmacrocallback","prefix":"defmc","body":"defmacrocallback $1 :: $0"},"dataSource":{"body":"dataSource: %{store: %{ref: \"${1:}\"}},","prefix":"dataSource"},"DynamicSupervisor":{"scope":"source.elixir","description":"Insert code for a DynamicSupervisor","prefix":"dynamic_supervisor","body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse DynamicSupervisor","","\tdef start_link(${init_args}) do","\t\tDynamicSupervisor.start_link(__MODULE__, [${init_args}], name: __MODULE__)","\tend","","\tdef start_child(${child_args}) do","\t\tchild_spec = %{","\t\t\tid: ${ChildModule},","\t\t\tstart: {${ChildModule}, :start_link, [${child_args}]},","\t\t\trestart: :transient,","\t\t\tshutdown: :brutal_kill,","\t\t\ttype: :worker,","\t\t\tmodules: [${ChildModule}],","\t\t}","","\t\tDynamicSupervisor.start_child(__MODULE__, child_spec)","\tend","","\tdef init([${init_args}]) do","\t\tDynamicSupervisor.init(strategy: :one_for_one)","\tend","end"]},"doc":{"scope":"source.elixir","description":"doc","prefix":"doc","body":"@doc \"\"\"\n$0\n\"\"\""},"journal":{"prefix":"journal","body":["def journal(\"check_results_debts_affil\", {:command, new_state, _}, _auth_data, _extra) do","    %{","      \"merge\" => %{","        check_affil_debts_finished_result: get_in(new_state, [\"affilation_and_debts\", \"finished\"]),","        company_ids_with_access: get_in(new_state, [\"affilation_and_debts\", \"finished\", \"participants\"])","          |> Enum.filter(fn {_k, v} -> v[\"deny\"] != true end)","          |> Enum.map(fn {k, _v} ->","            k = Utils.ensure_is_integer(k)","            get_in(new_state, [\"participants\", k, \"company_id\"])","          end)","      }","    }","  end"]},"unless:":{"scope":"source.elixir","description":"unless (one line)","prefix":"unless:","body":"unless $1, do: $0"},"df":{"scope":"source.elixir","description":"def (one line)","prefix":"df","body":"def $1, do: $0"},"unlesse":{"scope":"source.elixir","description":"unless else","prefix":"unlesse","body":"unless $1 do\n  $2\nelse\n  $0\nend"},"is_b":{"body":"is_boolean(${1:})","prefix":"is_b"},"cond":{"scope":"source.elixir","description":"cond","prefix":"cond","body":"cond do\n  $1 ->\n    $0\nend"},"mp":{"scope":"source.elixir","description":"Puts the given value under key in map","prefix":"mp","body":"Map.put(${1:map}, ${2:key}, ${3:value})"},"def":{"scope":"source.elixir","description":"def","prefix":"def","body":"def $1 do\n\t$0\nend"},"p":{"scope":"text.elixir","description":"your favorite pipeline (|>)","prefix":"p","body":"|> $0"},"ExUnit":{"scope":"source.elixir","description":"Insert code for a ExUnit","prefix":["ex_unit","exu"],"body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\tuse ExUnit.Case","\tdoctest$1","","\tdescribe \"${2:description_of_tests}\" do","\t\ttest \"${3:definition_of_this_test}\" do","\t\tend","\tend","end"]},"ife:":{"scope":"source.elixir","description":"if else (one line)","prefix":"ife:","body":"if $1, do: $2, else: $0"},"defd":{"scope":"source.elixir","description":"defdelegate","prefix":"defd","body":"defdelegate $1 to: $0"},"test":{"scope":"source.elixir","description":"test","prefix":"test","body":"test \"$1\" do\n\t$0\nend"},"extract_locale":{"body":["def extract_locale(params) do","    case params[:lang] do","      \"ru\" -> \"ru_RU\"","      \"ru_kg\" -> \"ru_RU@kg\"","      \"uz\" -> \"uz_UZ@cyrillic\"","      \"kg\" -> \"ky_KG\"","      \"en\" -> \"en_US\"","      \"en_kg\" -> \"en_US@kg\"","      o -> o","    end","  end"],"prefix":"extract_locale"},"unless":{"scope":"source.elixir","description":"unless","prefix":"unless","body":"unless $1 do\n  $0\nend"},"i":{"scope":"source.elixir","description":"inspect","prefix":"i","body":"inspect($0)"},"iil":{"scope":"source.elixir","description":"IO.inspect(label: ...)","prefix":"iil","body":"IO.inspect(label: \"$0\")"},"mdoc":{"scope":"source.elixir","description":"moduledoc","prefix":"mdoc","body":"@moduledoc \"\"\"\n$0\n\"\"\""},"iip":{"scope":"source.elixir","description":"IO.inspect() piped value with module name & line number","prefix":"iip","body":"|> IO.inspect(label: \"#{__MODULE__}:#{__ENV__.line} #{DateTime.utc_now}\", limit: :infinity)"},"alias_fa":{"prefix":"alias_fa","body":"alias FunctionalAbstraction, as: FA"},"debug time":{"body":["{time, result} = :timer.tc(fn ->","  ${1:}","end)","{time / 1_000, time / 1_000_000, result}"],"prefix":"debug time"},"fn":{"scope":"source.elixir","description":"fn","prefix":"fn","body":"fn ${1:args} -> $2 end$0"},"iib":{"scope":"source.elixir","description":"IO.inspect() binding() with module name & line number","prefix":"iib","body":"IO.inspect(binding(), label: \"binding() #{__MODULE__}:#{__ENV__.line} #{DateTime.utc_now}\", limit: :infinity)"},"ee":{"scope":"text.elixir,text.html.elixir","description":"embed_eex","prefix":"ee","body":"<% $0 %>"},"map_join_sql_in":{"body":"|> Enum.map_join(\"${1:,}\", &(\"'#{&1[${2:proc_id}]}'\"))","prefix":"map_join_sql_in"},"req":{"scope":"source.elixir","description":"require","prefix":"req","body":"require $0"},"case":{"scope":"source.elixir","description":"case","prefix":"case","body":"case $1 do\n  $2 ->\n    $0\nend"},"trr":{"scope":"source.elixir","description":"try rescue (everything!)","prefix":"trr","body":"try do\n  $0\nrescue\n  _ -> :rescued\nend"},"defpro":{"scope":"source.elixir","description":"defprotocol","prefix":"defpro","body":"defprotocol $1 do\n  $0\nend"},"defp":{"scope":"source.elixir","description":"defp","prefix":"defp","body":"defp $1 do\n\t$0\nend"},"dmac":{"scope":"source.elixir","description":"defmacro","prefix":["dmac","defmac"],"body":"defmacro $1 do\n\t$0\nend"},"pry":{"scope":"source.elixir","description":"Debug with IEx.pry","prefix":"pry","body":"require IEx; IEx.pry"},"rec":{"scope":"source.elixir","description":"receive","prefix":"rec","body":"receive do\n\t${1:{${2::${3:message_type}}, ${4:value}\\}} ->\n    ${0:# code}\nend\n"},"describe":{"scope":"source.elixir","description":"describe","prefix":"describe","body":"describe \"$1\" do\n\t$0\nend"},"dmod":{"scope":"source.elixir","prefix":["dmod","defmod"],"description":"def module","comments":["Generates the namespace for a file.","e.g. A file with the path `lib/foo/bar/baz/boing.ex` would resolve to Foo.Bar.Baz.Boing."],"body":["defmodule ${RELATIVE_FILEPATH/^([^\\/\\\\]+[\\/\\\\])|(\\.ex|\\.exs)$|([^._\\/\\\\]+)|_|([\\/\\\\])/${3:/capitalize}${4:+.}/g} do","\t$0","end"]},"imp":{"scope":"source.elixir","description":"import","prefix":"imp","body":"import $0"},"ist":{"scope":"source.elixir","description":"`IO.inspect` the current stacktrace","prefix":"ist","body":"IO.inspect(Process.info(self(), :current_stacktrace), label: \"STACKTRACE\", limit: :infinity)"},"defmp":{"scope":"source.elixir","description":"defmacrop","prefix":"defmp","body":"defmacrop $1 do\n\t$0\nend"},"if":{"scope":"source.elixir","description":"if","prefix":"if","body":"if $1 do\n  $0\nend"},"mfs":{"scope":"source.elixir","description":"Map from Struct","prefix":"mfs","body":"Map.from_struct($0)"},"trc":{"scope":"source.elixir","description":"try catch","prefix":"trc","body":"try do\n  $0\ncatch\n $1 -> $2\nend"},"defs":{"scope":"source.elixir","description":"defstruct","prefix":"defs","body":"defstruct $1: $2"},"defc":{"scope":"source.elixir","description":"defcallback","prefix":"defc","body":"defcallback $1 :: $0"},"wte":{"scope":"source.elixir","description":"with/else","prefix":"wte","body":["with $1 do","\t$0","else","\t$2 -> $3","end"]},"Inspect with relative path and line nr":{"scope":"source.elixir","description":"`IO.inspect` with a label containing relative path and line number. Label string can easily be discarded","prefix":"iins","body":"|> IO.inspect(label: \"${0:${RELATIVE_FILEPATH}:${TM_LINE_NUMBER}}\")"},"oke":{"scope":"source.elixir","description":"{:ok, ... } = ...","prefix":"ok","body":"{:ok, $1} = $0"},"ip":{"scope":"source.elixir","description":"IO.puts(..)","prefix":"iip","body":"IO.puts(\"$0\")"},"defi":{"scope":"source.elixir","description":"defimpl","prefix":"defi","body":"defimpl $1, for: $2 do\n  $0\nend"},"schma":{"body":["{","      \"shipping_date\" => %{","        __vali__: &(MsPP.Engines.CargoProcedure.FieldValueLogic.validate_shipping_date/2)","      },","      \"cargo_type_of_transport\" => %{","        __vali__: MsPP.Utils.CustomValidators.validate_length_list_by_op(:>, 0)","      },","      \"sum_of_positions_exchanges\" => %{","        __vali__: Vali.Validators.gt(0),","      },","      \"period_of_trading\" => %{","        __vali__: [Vali.Validators.gt(0), Vali.Validators.lt(91)],","      },","      \"cargo_weight_brutto_tons\" => %{","        error_label: gettext(\"Вес груза брутто\"),","        __vali__: fn value, state ->","          cond do","            is_nil(FA.value(state, \"cargo_weight_netto_tons\")) -> :valid","            value < FA.value(state, \"cargo_weight_netto_tons\") -> {:invalid, gettext(\"Брутто не может быть меньше чем нетто\")}","            true -> :valid","          end","        end,","      },","      \"cargo_weight_netto_tons\" => %{","        error_label: gettext(\"Вес груза нетто\"),","        __vali__: fn value, state ->","          cond do","            value > FA.value(state, \"cargo_weight_brutto_tons\") -> {:invalid, gettext(\"Нетто не может быть больше чем брутто\")}","            true -> :valid","          end","        end,","      }","    }"],"prefix":"schma"},"::":{"scope":"source.elixir","description":"key => value","prefix":"::","body":"${1:key} => ${2:value}$0"},"testc":{"scope":"source.elixir","description":"test with context","prefix":"testc","body":"test \"$1\", %{$2} do\n\t$0\nend"},"mpn":{"scope":"source.elixir","description":"Puts the given value under key unless the entry key already exists in map","prefix":"mpn","body":"Map.put_new(${1:map}, ${2:key}, ${3:value})"},"ii":{"scope":"source.elixir","description":"IO.inspect","prefix":"ii","body":"IO.inspect($0)"},"ife":{"scope":"source.elixir","description":"if else","prefix":"ife","body":"if $1 do\n  $2\nelse\n  $0\nend"},"if:":{"scope":"source.elixir","description":"if (one line)","prefix":"if:","body":"if $1, do: $0"},"defe":{"scope":"source.elixir","description":"defexception","prefix":"defe","body":"defexception [${1::message}]"},"ok":{"scope":"source.elixir","description":"{:ok, ... } ...","prefix":"ok","body":"{:ok, $1} $0"},"alias all":{"body":"alias MsPP.Engines.UZLogic.{CheckAffilationAndDebtsLogic, MultilotLogic, Utils, Team, Agreementation, Signature, DefaultAgreement, VersionManager, NewPurchaseList, Clearing, Chat}","prefix":"alias all"},":":{"scope":"source.elixir","description":"value: value","prefix":":","body":"${1:value}: ${1:value}$0"},"for":{"scope":"source.elixir","description":"for","prefix":"for","body":"for ${1:item} <- ${2:items} do\n  $0\nend"},"erre":{"scope":"source.elixir","description":"{:error, ... } = ...","prefix":"error","body":"{:error, $1} = $0"},"do":{"scope":"source.elixir","description":"do","prefix":"do","body":"do\n\t$0\nend"},"pe":{"scope":"text.elixir,text.html.elixir","description":"print_eex","prefix":"pe","body":"<%= $0 %>"},"fori":{"scope":"source.elixir","description":"for into","prefix":"fori","body":"for ${1:item} <- ${2:items}, into: ${3:[]} do;\n  $0\nend"},"iill":{"scope":"source.elixir","description":"IO.inspect(label: \"<optional message>; Module:line_nr\")","prefix":"iill","body":"IO.inspect(label: \"${0:message; }#{String.replace_leading(\"#{__ENV__.file}\", \"#{File.cwd!()}\",\"\")|> Path.relative()}:#{__ENV__.line()}\")"}}